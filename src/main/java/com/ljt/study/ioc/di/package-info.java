/**
 * @author LiJingTang
 * @version 2019年3月31日 上午10:18:47
 */
package com.ljt.study.ioc.di;

/**
	依赖注入
	依赖注入（DI）是对象定义它们依赖的过程，也就是说，要和它们协同工作其它对象，仅仅可以通过构造方法参数，工厂方法参数，或者是在工厂方法返回的对象或被构造好后，为对象实例设置的属性。
	容器当创建好bean，随后就会注入那些依赖。这个过程从根本上来说是反向的，因此命名为控制反转（IoC），
	bean本身直接使用构造好的类或服务定位器模式来控制实例或它的依赖的所在位置。DI存在两种主要的方式，基于构造方法的依赖注入和基于setter方法的依赖注入。
	
	基于构造方法的依赖注入是容器调用构造方法和一组参数完成的，每个都表示着一个依赖。
	构造方法参数解析
	构造方法参数解析匹配使用参数的类型。如果在bean的构造方法参数不存在潜在的歧义，那么当bean被实例化的时候，定义的构造方法参数的顺序就是被提供到适当构造方法参数的顺序。
	当使用简单类型时，比如<value>true<value>，Spring不能决定值的类型，所以没有帮助是不能匹配的。
	构造方法参数名称
	要记住要使得这种方式可用，代码必须和内嵌的调试标识一起编译，那样Spring才可以从构造方法中来查找参数。
	如果没有和调试标识（或不想）一起编译，那么可以使用JDK的注解@ConstructorProperties来明确构造方法参数。
	
	基于setter方法的依赖注入由容器在调用过无参数的构造方法或无参数的static工厂方法来实例化bean之后，再调用bean的setter方法来完成的。
	
	ApplicationContext对它管理的bean支持基于构造方法和setter方法的依赖注入。也支持在一些依赖已经通过构造方法注入之后再进行setter方法注入。
	以BeanDefinition形式来配置依赖，使用PropertyEditor实例将属性从一种形式格式化到另一种。
	但很多Spring的用户不直接（编程时）使用这些类，而是使用XML文件来定义，之后会在内部转换这些类的实例，需要加载整个Spring IoC容器的实例。
	
	
	基于构造方法还是setter方法进行依赖注入？
	有一个很好的规则就是为强制依赖使用构造方法参数，而对于可选参数使用setter方法。要注意在setter方法上使用注解@Required，可用于setter方法所需的依赖。
	Spring团队通常主张使用setter方法注入，因为大量的构造方法参数会使程序变得非常笨拙，特别是当属性为可选的时候。setter方法会让该类的对象今后适合于重新配置或重新注入。
	可以通过setter方法注入来配置循环依赖（A需要通过构造方法注入获得类B的实例，而类B也需要通过构造方法注入获得类A的实例。
	如果把类A和类B进行相互注入，Spring的IoC容器会在运行时检测到这是循环引用的情况，并且抛出BeanCurrentlyInCreationException异常。）。
	
	
	容器按如下步骤来解决bean的依赖：
	1.ApplicationContext和描述了所有bean的配置元数据一起被创建并初始化。配置元数据可以通过XML，Java代码或注解来指定。
	2.对于每一个bean来说，它的依赖被表述为属性，构造方法参数的形式，如果你使用了静态工厂方法来代替构造方法，那么还会是静态工厂方法参数的形式。当bean被实际创建时，这些依赖被提供给bean。
	3.每个属性或构造方法参数就是一个要被设置的值或者是容器中其它bean的引用。
	4.每个属性或构造方法参数值会被转换特定格式的形式，去匹配属性或构造方法参数的类型。默认情况下，Spring可以转换给定的字符串格式的值到内建的类型，比如int，long，String，boolean等。
	当容器被创建时，Spring容器会来验证每个bean的配置，包括验证bean的引用属性是否是一个合法的bean。然而，bean属性本身直到bean真正被创建出来后才被设置进去。
	如果没有循环依赖的存在，当一个或多个协作的bean被注入到一个独立的bean时，每个协作的bean就会在被注入之前完全被配置好。
	这就意味着如果bean A对bean B有依赖，那么Spring的IoC容器会完全配置bean B而优先于调用bean A中的setter方法。
	
	
	集合
	abstract="true" 使用abstract属性显式地将父bean定义标记为抽象的。由于这样的父bean是不完整的，而且还被显式标记为抽象的，因而它无法得到自己的实例。
	抽象bean定义可作为子bean定义的模板。若要尝试单独使用这样的父bean（比如将它作为其他bean的ref属性而引用，或者直接使用这个父bean的id作为参数调用getBean()方法），将会导致错误。
	
	在<list/>元素特定的情形下，和List集合类型相关的语义，也就是说，ordered集合值的概念，是要维护的；父值优先于所有子list的值。
	在Map，Set和Properties集合类型的情况下，没有顺序的存在。因此对于容器内部使用的，和Map，Set和Properties实现类型相关的集合类型没有排序语义的作用。
	
	集合合并的限制:不能合并不同类型的集合（比如Map和List），如果你要尝试这么去做，那么就会抛出Exception。
	merge属性必须在低级的，继承的，子bean中来指定；在父集合中指定merge属性是冗余的，也不会看到想要的合并结果。
	
	
	自动装配协作者
	自动装配可以显著减少指定属性或构造方法参数的需要。
  自动装配可以更新配置对象的演变。比如，如果你需要给一个类添加依赖，那个依赖可以自动被填入而不需要修改配置。
	因此，自动装配在开发期间是非常有用的，当代码库变得更稳定时切换到明确的装配也没有否定的选择。
	no：（default）没有自动装配。Bean的引用必须通过ref元素来定义。
		对于大型的部署，修改默认设置是不推荐的，因为明确地指定协作者会给予更多的控制和清晰。某种程度上来说，它勾勒出了系统的结构。
	byName：通过属性名称来自动装配。Spring以相同名称来查找需要被自动装配的bean。
		比如，如果bean被设置成由名称来自动装配，并含有一个master属性（也就说，有setMaster(..)方法），Spring会查找名为master的bean定义，并且用它来设置属性。
    byType：如果bean的属性类型在容器中存在的话，就允许属性被自动装配。
    	如果存在多于一个，就会抛出致命的异常，这就说明了对那个bean不能使用byType进行自动装配。如果没有匹配的bean存在，就不会有任何效果；属性不会被设置。
    constructor：和byType类似，但是是应用于构造方法参数的。如果在容器中没有确定的构造方法参数类型的bean的存在，就会发生致命的错误。
	
	从自动装配中排除bean
	在每个bean的基础上，你可以从自动装配中来排除bean。在Spring的XML格式配置中，设置<bean/>元素的autowire-candidate属性为false；
	容器会把指定的bean对自动装配不可用（包含注解风格的配置，比如@Autowired）。
	你也可以基于bean名称的模式匹配来限制自动装配候选者。顶级的<beans/>元素中的default-autowire-candidates属性接受一个或多个模式。
	这并不意味着未包含的bean不能使用自动装配来配置。相反，bean本身不是自动装配其它bean的候选者。

 */